(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[11],{"6GV8":function(e,n,t){"use strict";t.r(n),n.default="---\ntitle: \"Using EmberJS with XState\"\ndate: \"2021-06-09\"\n---\n\n![Ember with XState](/emberjs-with-xstate/ember-plus-xstate.png)\n\n> \u201cMachines take me by surprise with great frequency\u201d\n> - Alan Turing\n\n[Full Source Available on Github](https://github.com/Emerson/emberjs-xstate-example)\n\nOver the past year or so, the front end team at [iManage Closing Folders](https://www.closingfolders.com) has been experimenting with state machines and EmberJS. We've been pretty happy with the resulting code and I anticipate that we'll continue to use state machines moving forward. We still have a lot to learn about [XState](https://xstate.js.org/) itself _(it's a huge project)_, but I think we have enough knowledge to share some basics.\n\n_**Heads Up**: if you're interested in a deeper integration between EmberJS and XState I would suggest checking out [ember-statecharts](https://ember-statecharts.com). We specifically wanted to avoid adding more dependencies to our projects, but ember-statecharts looks great._\n\n### What Are the Benefits of State Machines?\n\n* It forces us to reconcile component design upfront by considering all the states we want our component to handle\n* It\u2019s a framework agnostic way of defining presentational state\n* It\u2019s easy to unit test\n* You can generate state diagrams from the code you write\n* Template code can be greatly simplified\n* **It eliminates emergent states in favour of explicit states**; as an example, if you have two boolean states on a component `isSaving` and `isError`, you actually have four states to consider.\n\n### What Are the Drawbacks?\n\n* It\u2019s yet another dependency\n* XState has a large conceptual overhead with lots of esoteric concepts\n* It\u2019s confusing if you don\u2019t have experience with it\n \n### The Plan\n\nThis is a contrived example, but I think it goes far enough to demonstrate the basics of using XState with EmberJS. We\u2019re going to look at how we can use XState and Ember to implement a _(very)_ basic signup form. This particular example could be implemented fairly easily using [ember-concurrency](http://ember-concurrency.com/), but in the wild our components are often much more complex and can justify the use of state machines.\n\nI won\u2019t be explaining XState in great detail, for that I would suggest watching the [free video series on egghead.io](https://egghead.io/courses/introduction-to-state-machines-using-xstate). Instead, this article will introduce some basic concepts and demonstrate how we develop XState powered components in Ember.\n\n### The Form\n\nLet\u2019s talk about this signup form. It\u2019s going to have two fields, a submit button, an error state, and a success state. Check out the GIF below to see the interactions:\n\n![Screenshot](/emberjs-with-xstate/state-machine-example.gif)\n\nWhen the user puts in any value for `username` and `password` we will display a success message. Otherwise we will display an error message and allow them to retry.\n\n### The State Machine\n\nIn abstract terms, this form will have 4 possible states: `idle`, `saving`, `success`, and `error`. Within XState we use the `createMachine` method to start defining our machine. The basic shape of an XState machine looks like this:\n\n```js\nimport { createMachine } from 'xstate';\n\ncreateMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  states: {\n    idle: {},\n    saving: {},\n    success: {},\n    error: {},\n  },\n});\n```\n\nWhat\u2019s so nice about this is that you can paste this code into the [XState Visualizer](https://xstate.js.org/viz/) and generate a diagram of how your state machine operates \u2013 \ud83c\udf89 super handy! \ud83c\udf89\n\n![XState Visualization 1](/emberjs-with-xstate/initial-states.png)\n\n### Moving Between States\n\nOur state machine is not very useful yet. As defined, it cannot transition between states. To enable that, we need to define [events](https://xstate.js.org/docs/guides/events.html) for each state using the [`on` property](https://xstate.js.org/docs/guides/transitions.html). Look at the `idle` state definition - here we are saying _\"when in the `idle` state, if the machine recives a `SUBMIT` event, transition to the `saving` state.\"_\n\n```js\nimport { createMachine } from 'xstate';\n\ncreateMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  states: {\n    idle: {\n      on: {\n        SUBMIT: 'saving'\n      },\n    },\n    saving: {\n      on: {\n        SUCCESS: 'success',\n        ERROR: 'error'\n      },\n    },\n    success: {},\n    error: {\n      on: {\n        RETRY: 'idle',\n      },\n    },\n  },\n});\n\n``` \n\nWith our events defined, our state visualization starts to make a lot more sense and we can now transition between states by sending our state machine events. \n\n![XState Visualization 2](/emberjs-with-xstate/states-with-transitions.png)\n\n```js\n//=> This would transition our machine to the `saving` state\nmachine.send({type: 'SUBMIT'});\n```\n\n### The Context Object\n\nThe next XState concept I want to touch on is the [`context` object](https://xstate.js.org/docs/guides/context.html). This is an object defined within our state machine that allows us to persist and pass around data. In our case we want to store the `username` and `password`.\n\n```js\nimport { createMachine } from 'xstate';\n\ncreateMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  // Lets add some context...\n  context: {\n    username: '',\n    password: '',\n  },\n  states: {\n    idle: {\n      on: {\n        SUBMIT: 'saving'\n      },\n    },\n    saving: {\n      on: {\n        SUCCESS: 'success',\n        ERROR: 'error'\n      },\n    },\n    success: {},\n    error: {\n      on: {\n        RETRY: 'idle',\n      },\n    },\n  },\n});\n```\n\nThere are a number of ways to set values on the context object, but I\u2019m going to give a simple example using an `action` callback. To learn more about actions I\u2019d suggest [checking out the docs](https://xstate.js.org/docs/guides/actions.html), there is a lot to unpack. In our case we are going to use an action callback to set the `username` and `password` property on our context object. When we send the `SUBMIT` event from our Ember app, we can attach extra information that comes through in our action callback.\n\n```js\n// When sending an event to the state machine you can pass extra data that becomes available in `action` callbacks\nmachine.send({\n  type: 'SUBMIT',\n  username: 'joe',\n  password: 'password123'\n});\n\n// ...\n// definition of our `idle` state\nidle: {\n  on: {\n    SUBMIT: {\n      target: 'saving', // transition to `saving`\n      actions: [\n        function(context, eventPayload) {\n          // eventPayload is the object we send to the machine\n          context.username = eventPayload.username;\n          context.password = eventPayload.password;\n        },\n      ],\n    },\n  },\n},\n// ...\n```\n\n### Saving the User (well\u2026 faking it anyway)\n\nThere are times when you may want a transition to be contingent on the results of an async operation rather than explicitly sending events to your machine. In our example, when the form is submitted we would likely hit an API and depending on the result, transition to either the `success` or `error` state.\n\nTo accomplish this we can use the [`invoke` property](https://xstate.js.org/docs/guides/communication.html) when defining our `saving` state. There is a lot to know about `invoke`, but in its most simple form it allows you to register a callback that returns a promise. In our case if the promise is `resolved` we want to transition to the `success` state, and if it\u2019s `rejected` we want to transition to the `error` state.\n\nCheck it out:\n\n```js\n\n// We define a \"service\" (callback) to invoke that returns a promise.\n// In our case I am trying to mock out an API call... Also, notice how this callback recives the context object\nfunction fakeServerResponse(context) {\n  return new Promise((resolve, reject) => {\n    later(() => {\n      if (context.username && context.password) {\n        resolve('Valid!');\n      } else {\n        reject('Invalid!');\n      }\n    }, 1000);\n  });\n}\n\n\n// ...\n// definition of our `saving` state\nsaving: {\n  invoke: {\n    id: 'fakeServerResponse',\n    src: fakeServerResponse,\n    onDone: {\n      target: 'success',\n    },\n    onError: {\n      target: 'error',\n    },\n  },\n},\n// ...\n```\n\n### The Final State Machine\n\nBelow you will find the state machine in its entirety. I\u2019ve made some slight adjustments to the action callback and added a couple extra properties, but it\u2019s largely the same as we defined above.  The resulting state visualization is awesome. Think about how helpful this could be when looking at a pull request.\n\n```js\nfunction fakeServerResponse(context) {\n  return new Promise((resolve, reject) => {\n    later(() => {\n      if (context.username && context.password) {\n        resolve('Valid!');\n      } else {\n        reject('Invalid!');\n      }\n    }, 1000);\n  });\n}\n\nlet signupFormMachine = createMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  context: {\n    username: '',\n    password: '',\n  },\n  states: {\n    idle: {\n      on: {\n        SUBMIT: {\n          target: 'saving',\n          actions: [\n            assign({\n              username: (context, event) => event.username,\n              password: (context, event) => event.password,\n            }),\n          ],\n        },\n      },\n    },\n    saving: {\n      invoke: {\n        id: 'fakeServerResponse',\n        src: fakeServerResponse,\n        onDone: {\n          target: 'success',\n        },\n        onError: {\n          target: 'error',\n        },\n      },\n    },\n    success: {\n      type: 'final',\n    },\n    error: {\n      on: {\n        RETRY: 'idle',\n      },\n    },\n  },\n});\n```\n\n![Final State Machine](/emberjs-with-xstate/final-state-machine.png)\n\n### What About Ember?\n\nSo this is actually the easy part! The basic premise here is that we instantiate our state machine within the constructor of our component. This allows us to hook into a `onTransition` callback that is exposed by XState. Every time our machine transitions, we just update the `state` attribute of our component.\n\nWe also add two actions to the component. One that handles general `send` events to our state machine and another that handles the form submit. I think it\u2019s pretty self explanatory if you\u2019re familiar with Ember.\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\nimport { later } from '@ember/runloop';\nimport { createMachine, interpret, assign } from 'xstate';\n\n// We would define the state machine here and assign it to a variable named \n// `signupFormMachine`. I've left this out for the sake of brevity, but you can see\n// it in the full source if needed.\n//\nlet signupFormMachine = createMachine(/* machine defined here */);\n\nexport default class SignupFormComponent extends Component {\n  @tracked state;\n  @tracked username;\n  @tracked password;\n\n  constructor() {\n    super(...arguments);\n    this.machine = interpret(signupFormMachine);\n    this.machine.start();\n    this.machine.onTransition((state) => {\n      this.state = state.value;\n    });\n  }\n\n  @action\n  send(eventName, e) {\n    e.preventDefault();\n    this.machine.send(eventName);\n  }\n\n  @action\n  submit(e) {\n    e.preventDefault();\n    this.machine.send({\n      type: 'SUBMIT',\n      username: this.username,\n      password: this.password,\n    });\n  }\n}\n```\n\n### Show Me the Handlebars!\n\nAlright, so let's check out the component template. It\u2019s pretty clean and easy to read since everything is relying on the state machine. The big things I like about this are:\n\n* There is no potential for weird emergent states. Our template conditionals are very clearly defined in simple  `#if` blocks using `ember-truth-helper` subexpressions.\n* For simple button clicks, we can just use the `(fn this.send 'EVENT_NAME')` pattern to proxy messages directly to the state machine.\n* If we need to do some extra work before sending an event to the state machine you can use a standard ember action like we\u2019ve done on the form submit event.\n\n```handlebars\n{{#if (or (eq this.state 'idle') (eq this.state 'saving'))}}\n\n  <form {{on 'submit' this.submit}} class=\"signup-form\" autocomplete=\"off\">\n\n    <div class=\"field\">\n      <label for=\"username\">Username</label>\n      <Input @id=\"username\" @type=\"text\" @value={{this.username}} />\n    </div>\n\n    <div class=\"field\">\n      <label for=\"password\">Password</label>\n      <Input @id=\"password\" @type=\"password\" @value={{this.password}} />\n    </div>\n\n    {{#if (eq this.state 'idle')}}\n      <input type=\"submit\" value=\"Create User\" />\n    {{/if}}\n\n    {{#if (eq this.state 'saving')}}\n      <input type=\"submit\" value=\"Saving...\" disabled />\n    {{/if}}\n\n  </form>\n\n{{/if}}\n\n{{#if (eq this.state 'success')}}\n  <div class=\"success\">\n    <p>\u2b50\ufe0f User created!</p>\n  </div>\n{{/if}}\n\n{{#if (eq this.state 'error')}}\n  <div class=\"error\">\n    <p>\ud83d\udeab There was an error submitting the form</p>\n    <button {{on 'click' (fn this.send 'RETRY')}}>\n      Try Again...\n    </button>\n  </div>\n{{/if}}\n```\n\nI hope this has been a somewhat compelling introduction to using XState and EmberJS. If you have any questions or comments feel free to reach out on [Twitter](https://twitter.com/emerson_lackey) or on the [EmberJS Discord](https://discord.com/invite/emberjs). If this is the type of thing that gets you fired up, please come work with us at iManage, [we're hiring](https://imanage.com/about/careers/#jobs)!"}}]);