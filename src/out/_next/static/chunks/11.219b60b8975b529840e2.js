(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[11],{"6GV8":function(e,n,t){"use strict";t.r(n),n.default="---\ntitle: \"Using EmberJS with XState\"\ndate: \"2021-06-09\"\n---\n\n![Ember with XState](/emberjs-with-xstate/ember-plus-xstate.png)\n\n> \u201cMachines take me by surprise with great frequency\u201d\n> - Alan Turing\n\n[Full Source Available on Github](https://github.com/Emerson/emberjs-xstate-example)\n\nAfter some experimentation with state machines and EmberJS, I figured it would be worth sharing some of our learnings with the broader JavaScript community. We\u2019ve only just started building out components with [XState](https://xstate.js.org/), but I think we\u2019re seeing the value already and plan to continue using it when building new components.\n\n### What are the benefits?\n\n* It forces us to reconcile component states upfront during planning\n* It\u2019s a framework agnostic way of defining presentational state\n* It\u2019s easy to unit test\n* You can generate state diagrams from the code you write\n* Template code can be greatly simplified\n* It eliminates emergent states by definition explicit states\n\n### What are the drawbacks?\n\n* It\u2019s yet another dependency\n* XState has large conceptual overhead with lots of esoteric concepts\n* It\u2019s confusing if you don\u2019t have experience with it\n \n### The Plan\n\nThis is a contrived example, but I think it goes far enough to demonstrate the basics of using XState with EmberJS. We\u2019re going to look at how we could use XState and Ember to implement a _(very)_ basic signup form.\n\nI won\u2019t be explaining XState in great detail, for that I would suggest watching the [free video series on egghead.io](https://egghead.io/courses/introduction-to-state-machines-using-xstate). Instead, this article will introduce some basic concepts and demonstrate how we develop XState powered components in Ember.\n\n### The Form\n\nLet\u2019s talk about this signup form. It\u2019s going to have two fields, a submit button, an error state, and a success state. Check out the GIF below to see an example:\n\n![Screenshot](/emberjs-with-xstate/state-machine-example.gif)\n\nWhen the user puts in any value for `username` and `password` we will display a success message. Otherwise we will display an error message and allow them to retry.\n\n### The State machine\n\nIn abstract terms, this form will have 4 possible states: `idle`, `saving`, `success`, and `error`. Within XState we use the `createMachine` method to start defining our machine. The basic shape of an XState machine looks like this:\n\n```js\nimport { createMachine } from 'xstate';\n\ncreateMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  states: {\n    idle: {},\n    saving: {},\n    success: {},\n    error: {},\n  },\n});\n```\n\nWhat\u2019s so nice about this is that you can paste your code into the [XState Visualizer](https://xstate.js.org/viz/) and generate an visual of how your state machine operates \u2013 \ud83c\udf89 super handy! \ud83c\udf89\n\n![XState Visualization 1](/emberjs-with-xstate/initial-states.png)\n\n### Moving Between States\n\nOur state machine is not very useful yet. As defined, it cannot transition between states. To enable that, we need to define [events](https://xstate.js.org/docs/guides/events.html) for each state using the [`on` property](https://xstate.js.org/docs/guides/transitions.html).\n\n```js\nimport { createMachine } from 'xstate';\n\ncreateMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  states: {\n    idle: {\n      on: {\n        SUBMIT: 'saving'\n      },\n    },\n    saving: {\n      on: {\n        SUCCESS: 'success',\n        ERROR: 'error'\n      },\n    },\n    success: {},\n    error: {\n      on: {\n        RETRY: 'idle',\n      },\n    },\n  },\n});\n\n``` \n\nWith our events defined, our state visualization starts to make a little more sense and we can now transition between states by sending our state machine an event. \n\n![XState Visualization 2](/emberjs-with-xstate/states-with-transitions.png)\n\n```js\n//=> This would transition our machine to the `saving` state\nmachine.send({type: 'SUBMIT'});\n```\n\n### The Context Object\n\nThe next XState concept I want to touch on is the [`context` object](https://xstate.js.org/docs/guides/context.html). This is an object defined within our state machine that allows you to persist and pass around data. In our case we are going to store the `username` and `password`.\n\n```js\nimport { createMachine } from 'xstate';\n\ncreateMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  // Lets add some context...\n  context: {\n    username: '',\n    password: '',\n  },\n  states: {\n    idle: {\n      on: {\n        SUBMIT: 'saving'\n      },\n    },\n    saving: {\n      on: {\n        SUCCESS: 'success',\n        ERROR: 'error'\n      },\n    },\n    success: {},\n    error: {\n      on: {\n        RETRY: 'idle',\n      },\n    },\n  },\n});\n```\n\nThere are a number of ways to set values on this context object, I\u2019m going to give a simple example using an `action` callback. To learn more about actions I\u2019d suggest [checking out the docs](https://xstate.js.org/docs/guides/actions.html), there is a lot to unpack.\n\n```js\n// When sending an event to the state machine you can pass extra data that becomes available in `action` callbacks\nmachine.send({\n  type: 'SUBMIT',\n  username: 'joe',\n  password: 'password123'\n});\n\n// ...\n// definition of our `idle` state\nidle: {\n  on: {\n    SUBMIT: {\n      target: 'saving', // transition to `saving`\n      actions: [\n        function(context, eventPayload) {\n          // eventPayload is the object we send to the machine\n          context.username = eventPayload.username;\n          context.password = eventPayload.password;\n        },\n      ],\n    },\n  },\n},\n// ...\n```\n\n### Saving the user (well\u2026 faking it anyway)\n\nThere are times when you may want a transition to be contingent on the results of an async operation. In our example, when the form is submitted we would likely hit the API and depending the result, transition to either the `success` or `error` state.\n\nTo accomplish this we can use the [`invoke` property](https://xstate.js.org/docs/guides/communication.html) when defining our `saving` state. There is a lot to know about `invoke`, but in its most simple form it allows you to register a callback that returns a promise. In our case if the promise is `resolved` we want to transition to the `success` state, and if it\u2019s `rejected` we want to transition to the `error` state.\n\nThis looks something like this:\n\n```js\n\n// We define a \"service\" (callback) to invoke that returns a promise.\n// In our case I am trying to mock out an API call... notice how this callback recives the context object\nfunction fakeServerResponse(context) {\n  return new Promise((resolve, reject) => {\n    later(() => {\n      if (context.username && context.password) {\n        resolve('Valid!');\n      } else {\n        reject('Invalid!');\n      }\n    }, 1000);\n  });\n}\n\n\n// ...\n// definition of our `saving` state\nsaving: {\n  invoke: {\n    id: 'fakeServerResponse',\n    src: fakeServerResponse,\n    onDone: {\n      target: 'success',\n    },\n    onError: {\n      target: 'error',\n    },\n  },\n},\n// ...\n```\n\n### The Final State Machine\n\nBelow you will find the state machine in its entirety. I\u2019ve made some slight adjustments to the action callback and added a couple extra properties, but it\u2019s largely the same as we defined above.  The resulting state visualization awesome. Think about how helpful this could be when looking at a pull request.\n\n```js\nfunction fakeServerResponse(context) {\n  return new Promise((resolve, reject) => {\n    later(() => {\n      if (context.username && context.password) {\n        resolve('Valid!');\n      } else {\n        reject('Invalid!');\n      }\n    }, 1000);\n  });\n}\n\nlet signupFormMachine = createMachine({\n  id: 'signup-form',\n  initial: 'idle',\n  context: {\n    username: '',\n    password: '',\n  },\n  states: {\n    idle: {\n      on: {\n        SUBMIT: {\n          target: 'saving',\n          actions: [\n            assign({\n              username: (context, event) => event.username,\n              password: (context, event) => event.password,\n            }),\n          ],\n        },\n      },\n    },\n    saving: {\n      invoke: {\n        id: 'fakeServerResponse',\n        src: fakeServerResponse,\n        onDone: {\n          target: 'success',\n        },\n        onError: {\n          target: 'error',\n        },\n      },\n    },\n    success: {\n      type: 'final',\n    },\n    error: {\n      on: {\n        RETRY: 'idle',\n      },\n    },\n  },\n});\n```\n\n![Final State Machine](/emberjs-with-xstate/final-state-machine.png)\n\n### What About Ember?\n\nThis is actually the easy part! The basic premise here is that we instantiate our state machine within the constructor of our component. This allows us to hook into a `onTransition` callback that is exposed by XState. Every time our machine transitions, we update the `state` attribute of the component. This allows us to use simple logic in the component template to show or hide particular UI.\n\nWe also add two actions to the component. One that handles general `send` events to our machine and another that handles the form submit. I think it\u2019s pretty self explanatory if you\u2019re familiar with Ember.\n\n```js\nimport Component from '@glimmer/component';\nimport { tracked } from '@glimmer/tracking';\nimport { action } from '@ember/object';\nimport { later } from '@ember/runloop';\nimport { createMachine, interpret, assign } from 'xstate';\n\n// We would define the state machine here and assign it to a variable named \n// `signupFormMachine`. I've left this out for the sake of brevity, but you can see\n// it in the full source if needed.\n//\nlet signupFormMachine = createMachine(/* machine defined here */);\n\nexport default class SignupFormComponent extends Component {\n  @tracked state;\n  @tracked username;\n  @tracked password;\n\n  constructor() {\n    super(...arguments);\n    this.machine = interpret(signupFormMachine);\n    this.machine.start();\n    this.machine.onTransition((state) => {\n      this.state = state.value;\n    });\n  }\n\n  @action\n  send(eventName, e) {\n    e.preventDefault();\n    this.machine.send(eventName);\n  }\n\n  @action\n  submit(e) {\n    e.preventDefault();\n    this.machine.send({\n      type: 'SUBMIT',\n      username: this.username,\n      password: this.password,\n    });\n  }\n}\n```\n\n### Show Me the Handlebars!\n\nAlright, so let's check out the component template. It\u2019s pretty clean and easy to read since everything is relying on the state machine. The big things I like about this are:\n\n* There is no potential for weird emergent states. Our template conditionals are very clearly defined in simple  `#if` blocks using `ember-truth-helper` subexpressions.\n* For simple button clicks, we can just use the `(fn this.send 'EVENT_NAME')` pattern to proxy messages directly to the state machine.\n* If we need to do some extra work before sending an event to the state machine you can use a standard ember action like we\u2019ve done on the form submit event.\n\n```handlebars\n{{#if (or (eq this.state 'idle') (eq this.state 'saving'))}}\n\n  <form {{on 'submit' this.submit}} class=\"signup-form\" autocomplete=\"off\">\n\n    <div class=\"field\">\n      <label for=\"username\">Username</label>\n      <Input @id=\"username\" @type=\"text\" @value={{this.username}} />\n    </div>\n\n    <div class=\"field\">\n      <label for=\"password\">Password</label>\n      <Input @id=\"password\" @type=\"password\" @value={{this.password}} />\n    </div>\n\n    {{#if (eq this.state 'idle')}}\n      <input type=\"submit\" value=\"Create User\" />\n    {{/if}}\n\n    {{#if (eq this.state 'saving')}}\n      <input type=\"submit\" value=\"Saving...\" disabled />\n    {{/if}}\n\n  </form>\n\n{{/if}}\n\n{{#if (eq this.state 'success')}}\n  <div class=\"success\">\n    <p>\u2b50\ufe0f User created!</p>\n  </div>\n{{/if}}\n\n{{#if (eq this.state 'error')}}\n  <div class=\"error\">\n    <p>\ud83d\udeab There was an error submitting the form</p>\n    <button {{on 'click' (fn this.send 'RETRY')}}>\n      Try Again...\n    </button>\n  </div>\n{{/if}}\n```\n\nI hope this has been a somewhat compelling introduction to using XState and EmberJS. If you have any questions or comments feel free to reach out on [Twitter](https://twitter.com/emerson_lackey) or on the EmberJS Discourse."}}]);